{
    "title": "SQLAlchemy",
    "icon": "devicon-sqlalchemy-plain",
    "experience": 88,
    "overview": "SQLAlchemy is my preferred ORM for Python projects, providing a flexible and powerful way to interact with databases using Pythonic code.",
    "usage": "I use SQLAlchemy to abstract database operations, making code more maintainable and database-agnostic. It's particularly useful for complex data models and relationships.",
    "projects": ["LLM Platform", "Content Management System", "Data Processing Pipeline"],
    "insight": "<p>SQLAlchemy's power comes from its flexibility in allowing both high-level ORM operations and low-level SQL when needed:</p><div class=\"code-example\">from sqlalchemy import create_engine, Column, Integer, String, ForeignKey, func\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship, sessionmaker\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True)\n    username = Column(String, unique=True, nullable=False)\n    email = Column(String, unique=True, nullable=False)\n    conversations = relationship(\"Conversation\", back_populates=\"user\")\n\nclass Conversation(Base):\n    __tablename__ = 'conversations'\n    id = Column(Integer, primary_key=True)\n    title = Column(String, nullable=False)\n    created_at = Column(DateTime, default=func.now())\n    user_id = Column(Integer, ForeignKey('users.id'))\n    user = relationship(\"User\", back_populates=\"conversations\")\n    messages = relationship(\"Message\", back_populates=\"conversation\")\n\n# Custom query methods\ndef get_recent_conversations(session, user_id, limit=10):\n    return session.query(Conversation)\n        .filter(Conversation.user_id == user_id)\n        .order_by(Conversation.created_at.desc())\n        .limit(limit)\n        .all()\n\ndef get_conversation_stats(session):\n    return session.execute(\"\"\"\n        SELECT \n            users.username,\n            COUNT(conversations.id) as conversation_count,\n            AVG(message_counts.count) as avg_messages_per_conversation\n        FROM users\n        JOIN conversations ON users.id = conversations.user_id\n        JOIN (\n            SELECT conversation_id, COUNT(*) as count\n            FROM messages\n            GROUP BY conversation_id\n        ) as message_counts ON conversations.id = message_counts.conversation_id\n        GROUP BY users.id\n        ORDER BY conversation_count DESC\n    \"\"\").fetchall()</div><p>This hybrid approach gives me the productivity benefits of an ORM while still allowing optimization for complex queries when needed.</p>"
  }
  